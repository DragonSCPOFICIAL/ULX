// ============================================================================
// ULX Standard Library Extended
// Biblioteca padrão expandida para a linguagem ULX
// Versão: 2.0.0
// Autor: Dragon SCP
// ============================================================================

// ----------------------------------------------------------------------------
// SEÇÃO 1: SYSCALLS BÁSICAS DO KERNEL LINUX
// ----------------------------------------------------------------------------

// Syscalls de I/O de arquivos
syscall read(fd: i32, buffer: ptr, count: usize) -> isize {
    asm("mov rax, 0");
    asm("mov rdi, %0" : : "r"(fd));
    asm("mov rsi, %0" : : "r"(buffer));
    asm("mov rdx, %0" : : "r"(count));
    asm("syscall");
    asm("ret");
}

syscall write(fd: i32, buffer: ptr, count: usize) -> isize {
    asm("mov rax, 1");
    asm("mov rdi, %0" : : "r"(fd));
    asm("mov rsi, %0" : : "r"(buffer));
    asm("mov rdx, %0" : : "r"(count));
    asm("syscall");
    asm("ret");
}

syscall open(path: ptr, flags: i32, mode: i32) -> i32 {
    asm("mov rax, 2");
    asm("mov rdi, %0" : : "r"(path));
    asm("mov rsi, %0" : : "r"(flags));
    asm("mov rdx, %0" : : "r"(mode));
    asm("syscall");
    asm("ret");
}

syscall close(fd: i32) -> i32 {
    asm("mov rax, 3");
    asm("mov rdi, %0" : : "r"(fd));
    asm("syscall");
    asm("ret");
}

// Syscalls de processos
syscall fork() -> i32 {
    asm("mov rax, 57");
    asm("syscall");
    asm("ret");
}

syscall execve(path: ptr, argv: ptr, envp: ptr) -> i32 {
    asm("mov rax, 59");
    asm("mov rdi, %0" : : "r"(path));
    asm("mov rsi, %0" : : "r"(argv));
    asm("mov rdx, %0" : : "r"(envp));
    asm("syscall");
    asm("ret");
}

syscall exit(status: i32) {
    asm("mov rax, 60");
    asm("mov rdi, %0" : : "r"(status));
    asm("syscall");
}

syscall waitpid(pid: i32, status: ptr, options: i32) -> i32 {
    asm("mov rax, 61");
    asm("mov rdi, %0" : : "r"(pid));
    asm("mov rsi, %0" : : "r"(status));
    asm("mov rdx, %0" : : "r"(options));
    asm("syscall");
    asm("ret");
}

// Syscalls de memória
syscall mmap(addr: ptr, length: usize, prot: i32, flags: i32, fd: i32, offset: i64) -> ptr {
    asm("mov rax, 9");
    asm("mov rdi, %0" : : "r"(addr));
    asm("mov rsi, %0" : : "r"(length));
    asm("mov rdx, %0" : : "r"(prot));
    asm("mov r10, %0" : : "r"(flags));
    asm("mov r8, %0" : : "r"(fd));
    asm("mov r9, %0" : : "r"(offset));
    asm("syscall");
    asm("ret");
}

syscall munmap(addr: ptr, length: usize) -> i32 {
    asm("mov rax, 11");
    asm("mov rdi, %0" : : "r"(addr));
    asm("mov rsi, %0" : : "r"(length));
    asm("syscall");
    asm("ret");
}

syscall brk(addr: ptr) -> ptr {
    asm("mov rax, 12");
    asm("mov rdi, %0" : : "r"(addr));
    asm("syscall");
    asm("ret");
}

// Syscalls de tempo
syscall nanosleep(req: ptr, rem: ptr) -> i32 {
    asm("mov rax, 35");
    asm("mov rdi, %0" : : "r"(req));
    asm("mov rsi, %0" : : "r"(rem));
    asm("syscall");
    asm("ret");
}

syscall gettimeofday(tv: ptr, tz: ptr) -> i32 {
    asm("mov rax, 96");
    asm("mov rdi, %0" : : "r"(tv));
    asm("mov rsi, %0" : : "r"(tz));
    asm("syscall");
    asm("ret");
}

// Syscalls de rede
syscall socket(domain: i32, type: i32, protocol: i32) -> i32 {
    asm("mov rax, 41");
    asm("mov rdi, %0" : : "r"(domain));
    asm("mov rsi, %0" : : "r"(type));
    asm("mov rdx, %0" : : "r"(protocol));
    asm("syscall");
    asm("ret");
}

syscall bind(sockfd: i32, addr: ptr, addrlen: u32) -> i32 {
    asm("mov rax, 49");
    asm("mov rdi, %0" : : "r"(sockfd));
    asm("mov rsi, %0" : : "r"(addr));
    asm("mov rdx, %0" : : "r"(addrlen));
    asm("syscall");
    asm("ret");
}

syscall listen(sockfd: i32, backlog: i32) -> i32 {
    asm("mov rax, 50");
    asm("mov rdi, %0" : : "r"(sockfd));
    asm("mov rsi, %0" : : "r"(backlog));
    asm("syscall");
    asm("ret");
}

syscall accept(sockfd: i32, addr: ptr, addrlen: ptr) -> i32 {
    asm("mov rax, 43");
    asm("mov rdi, %0" : : "r"(sockfd));
    asm("mov rsi, %0" : : "r"(addr));
    asm("mov rdx, %0" : : "r"(addrlen));
    asm("syscall");
    asm("ret");
}

syscall connect(sockfd: i32, addr: ptr, addrlen: u32) -> i32 {
    asm("mov rax, 42");
    asm("mov rdi, %0" : : "r"(sockfd));
    asm("mov rsi, %0" : : "r"(addr));
    asm("mov rdx, %0" : : "r"(addrlen));
    asm("syscall");
    asm("ret");
}

// ----------------------------------------------------------------------------
// SEÇÃO 2: MANIPULAÇÃO DE STRINGS
// ----------------------------------------------------------------------------

func strlen(s: ptr) -> usize {
    var len: usize = 0;
    var p: ptr = s;
    while (*p != 0) {
        len = len + 1;
        p = p + 1;
    }
    return len;
}

func strcmp(s1: ptr, s2: ptr) -> i32 {
    var p1: ptr = s1;
    var p2: ptr = s2;
    while (*p1 == *p2 && *p1 != 0) {
        p1 = p1 + 1;
        p2 = p2 + 1;
    }
    return *p1 - *p2;
}

func strcpy(dest: ptr, src: ptr) -> ptr {
    var d: ptr = dest;
    var s: ptr = src;
    while (*s != 0) {
        *d = *s;
        d = d + 1;
        s = s + 1;
    }
    *d = 0;
    return dest;
}

func strcat(dest: ptr, src: ptr) -> ptr {
    var d: ptr = dest;
    while (*d != 0) {
        d = d + 1;
    }
    strcpy(d, src);
    return dest;
}

func strncpy(dest: ptr, src: ptr, n: usize) -> ptr {
    var d: ptr = dest;
    var s: ptr = src;
    var i: usize = 0;
    while (i < n && *s != 0) {
        *d = *s;
        d = d + 1;
        s = s + 1;
        i = i + 1;
    }
    while (i < n) {
        *d = 0;
        d = d + 1;
        i = i + 1;
    }
    return dest;
}

func strchr(s: ptr, c: i8) -> ptr {
    var p: ptr = s;
    while (*p != 0) {
        if (*p == c) {
            return p;
        }
        p = p + 1;
    }
    return 0;
}

func strstr(haystack: ptr, needle: ptr) -> ptr {
    var h: ptr = haystack;
    var needle_len: usize = strlen(needle);
    
    while (*h != 0) {
        var i: usize = 0;
        var found: bool = true;
        
        while (i < needle_len) {
            if (*(h + i) != *(needle + i)) {
                found = false;
                break;
            }
            i = i + 1;
        }
        
        if (found) {
            return h;
        }
        h = h + 1;
    }
    return 0;
}

// ----------------------------------------------------------------------------
// SEÇÃO 3: MANIPULAÇÃO DE MEMÓRIA
// ----------------------------------------------------------------------------

func memset(s: ptr, c: i8, n: usize) -> ptr {
    var p: ptr = s;
    var i: usize = 0;
    while (i < n) {
        *p = c;
        p = p + 1;
        i = i + 1;
    }
    return s;
}

func memcpy(dest: ptr, src: ptr, n: usize) -> ptr {
    var d: ptr = dest;
    var s: ptr = src;
    var i: usize = 0;
    while (i < n) {
        *d = *s;
        d = d + 1;
        s = s + 1;
        i = i + 1;
    }
    return dest;
}

func memmove(dest: ptr, src: ptr, n: usize) -> ptr {
    var d: ptr = dest;
    var s: ptr = src;
    
    if (d < s) {
        var i: usize = 0;
        while (i < n) {
            *d = *s;
            d = d + 1;
            s = s + 1;
            i = i + 1;
        }
    } else {
        d = d + n - 1;
        s = s + n - 1;
        var i: usize = 0;
        while (i < n) {
            *d = *s;
            d = d - 1;
            s = s - 1;
            i = i + 1;
        }
    }
    return dest;
}

func memcmp(s1: ptr, s2: ptr, n: usize) -> i32 {
    var p1: ptr = s1;
    var p2: ptr = s2;
    var i: usize = 0;
    while (i < n) {
        if (*p1 != *p2) {
            return *p1 - *p2;
        }
        p1 = p1 + 1;
        p2 = p2 + 1;
        i = i + 1;
    }
    return 0;
}

// Alocador de memória simples (heap)
global heap_start: ptr = 0;
global heap_end: ptr = 0;
global heap_current: ptr = 0;

func heap_init(size: usize) -> bool {
    heap_start = brk(0);
    if (heap_start == 0) {
        return false;
    }
    
    heap_end = brk(heap_start + size);
    if (heap_end != heap_start + size) {
        return false;
    }
    
    heap_current = heap_start;
    return true;
}

func malloc(size: usize) -> ptr {
    if (heap_start == 0) {
        heap_init(1048576); // 1MB default
    }
    
    var aligned_size: usize = (size + 7) & ~7; // Alinhamento de 8 bytes
    var ptr: ptr = heap_current;
    
    if (heap_current + aligned_size > heap_end) {
        // Expandir heap
        var new_end: ptr = brk(heap_end + aligned_size + 65536);
        if (new_end <= heap_end) {
            return 0; // Falha ao expandir
        }
        heap_end = new_end;
    }
    
    heap_current = heap_current + aligned_size;
    return ptr;
}

func free(ptr: ptr) {
    // Implementação simplificada - não libera memória
    // Uma implementação real usaria uma lista encadeada de blocos livres
}

// ----------------------------------------------------------------------------
// SEÇÃO 4: OPERAÇÕES MATEMÁTICAS
// ----------------------------------------------------------------------------

func abs(x: i32) -> i32 {
    if (x < 0) {
        return -x;
    }
    return x;
}

func min(a: i32, b: i32) -> i32 {
    if (a < b) {
        return a;
    }
    return b;
}

func max(a: i32, b: i32) -> i32 {
    if (a > b) {
        return a;
    }
    return b;
}

func pow(base: i32, exp: u32) -> i32 {
    var result: i32 = 1;
    var i: u32 = 0;
    while (i < exp) {
        result = result * base;
        i = i + 1;
    }
    return result;
}

func sqrt(x: i32) -> i32 {
    if (x < 2) {
        return x;
    }
    
    var left: i32 = 1;
    var right: i32 = x / 2;
    var result: i32 = 0;
    
    while (left <= right) {
        var mid: i32 = left + (right - left) / 2;
        
        if (mid <= x / mid) {
            result = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}

func factorial(n: u32) -> u64 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

func gcd(a: i32, b: i32) -> i32 {
    while (b != 0) {
        var temp: i32 = b;
        b = a % b;
        a = temp;
    }
    return abs(a);
}

func lcm(a: i32, b: i32) -> i32 {
    return abs(a * b) / gcd(a, b);
}

// ----------------------------------------------------------------------------
// SEÇÃO 5: CONVERSÃO DE TIPOS
// ----------------------------------------------------------------------------

func itoa(value: i32, buffer: ptr, base: i32) -> ptr {
    const digits: ptr = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var tmp: i8[36];
    var i: i32 = 0;
    var is_negative: bool = false;
    
    if (value == 0) {
        buffer[0] = '0';
        buffer[1] = 0;
        return buffer;
    }
    
    if (value < 0 && base == 10) {
        is_negative = true;
        value = -value;
    }
    
    while (value != 0) {
        tmp[i] = digits[value % base];
        value = value / base;
        i = i + 1;
    }
    
    var j: i32 = 0;
    if (is_negative) {
        buffer[j] = '-';
        j = j + 1;
    }
    
    while (i > 0) {
        i = i - 1;
        buffer[j] = tmp[i];
        j = j + 1;
    }
    buffer[j] = 0;
    
    return buffer;
}

func atoi(str: ptr) -> i32 {
    var result: i32 = 0;
    var sign: i32 = 1;
    var i: i32 = 0;
    
    // Skip whitespace
    while (str[i] == ' ' || str[i] == '\t' || str[i] == '\n') {
        i = i + 1;
    }
    
    // Handle sign
    if (str[i] == '-') {
        sign = -1;
        i = i + 1;
    } else if (str[i] == '+') {
        i = i + 1;
    }
    
    // Convert digits
    while (str[i] >= '0' && str[i] <= '9') {
        result = result * 10 + (str[i] - '0');
        i = i + 1;
    }
    
    return sign * result;
}

func ftoa(value: f32, buffer: ptr, precision: i32) -> ptr {
    var int_part: i32 = value as i32;
    var frac_part: f32 = value - int_part as f32;
    
    if (frac_part < 0) {
        frac_part = -frac_part;
    }
    
    var i: i32 = 0;
    if (value < 0 && int_part == 0) {
        buffer[i] = '-';
        i = i + 1;
    }
    
    itoa(int_part, buffer + i, 10);
    i = strlen(buffer);
    
    buffer[i] = '.';
    i = i + 1;
    
    var j: i32 = 0;
    while (j < precision) {
        frac_part = frac_part * 10;
        var digit: i32 = frac_part as i32;
        buffer[i] = '0' + digit;
        i = i + 1;
        frac_part = frac_part - digit as f32;
        j = j + 1;
    }
    
    buffer[i] = 0;
    return buffer;
}

// ----------------------------------------------------------------------------
// SEÇÃO 6: I/O DE CONSOLE
// ----------------------------------------------------------------------------

func print(s: ptr) -> i32 {
    var len: usize = strlen(s);
    return write(1, s, len);
}

func println(s: ptr) -> i32 {
    print(s);
    return write(1, "\n", 1);
}

func print_int(n: i32) -> i32 {
    var buffer: i8[32];
    itoa(n, &buffer, 10);
    return print(&buffer);
}

func print_hex(n: i32) -> i32 {
    var buffer: i8[32];
    print("0x");
    itoa(n, &buffer, 16);
    return print(&buffer);
}

func print_float(f: f32, precision: i32) -> i32 {
    var buffer: i8[64];
    ftoa(f, &buffer, precision);
    return print(&buffer);
}

func getchar() -> i8 {
    var c: i8;
    read(0, &c, 1);
    return c;
}

func readline(buffer: ptr, max_size: usize) -> i32 {
    var i: usize = 0;
    while (i < max_size - 1) {
        var c: i8 = getchar();
        if (c == '\n' || c == 0) {
            break;
        }
        buffer[i] = c;
        i = i + 1;
    }
    buffer[i] = 0;
    return i;
}

// ----------------------------------------------------------------------------
// SEÇÃO 7: OPERAÇÕES DE ARQUIVO
// ----------------------------------------------------------------------------

const O_RDONLY: i32 = 0;
const O_WRONLY: i32 = 1;
const O_RDWR: i32 = 2;
const O_CREAT: i32 = 64;
const O_TRUNC: i32 = 512;
const O_APPEND: i32 = 1024;

func file_read_all(path: ptr, buffer: ptr, size: usize) -> isize {
    var fd: i32 = open(path, O_RDONLY, 0);
    if (fd < 0) {
        return -1;
    }
    
    var bytes_read: isize = read(fd, buffer, size);
    close(fd);
    return bytes_read;
}

func file_write_all(path: ptr, data: ptr, size: usize) -> isize {
    var fd: i32 = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        return -1;
    }
    
    var bytes_written: isize = write(fd, data, size);
    close(fd);
    return bytes_written;
}

func file_exists(path: ptr) -> bool {
    var fd: i32 = open(path, O_RDONLY, 0);
    if (fd < 0) {
        return false;
    }
    close(fd);
    return true;
}

func file_copy(src: ptr, dest: ptr) -> bool {
    var buffer: i8[4096];
    var src_fd: i32 = open(src, O_RDONLY, 0);
    if (src_fd < 0) {
        return false;
    }
    
    var dest_fd: i32 = open(dest, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (dest_fd < 0) {
        close(src_fd);
        return false;
    }
    
    var bytes_read: isize;
    while ((bytes_read = read(src_fd, &buffer, 4096)) > 0) {
        write(dest_fd, &buffer, bytes_read);
    }
    
    close(src_fd);
    close(dest_fd);
    return true;
}

// ----------------------------------------------------------------------------
// SEÇÃO 8: ESTRUTURAS DE DADOS
// ----------------------------------------------------------------------------

// Vector dinâmico
struct Vector {
    data: ptr;
    size: usize;
    capacity: usize;
}

func vector_new() -> Vector {
    var v: Vector;
    v.data = malloc(16 * 8); // Capacidade inicial de 16 elementos (8 bytes cada)
    v.size = 0;
    v.capacity = 16;
    return v;
}

func vector_push(v: ptr Vector, value: i64) {
    if (v->size >= v->capacity) {
        // Dobrar a capacidade
        v->capacity = v->capacity * 2;
        var new_data: ptr = malloc(v->capacity * 8);
        memcpy(new_data, v->data, v->size * 8);
        v->data = new_data;
    }
    
    var data_ptr: ptr i64 = v->data;
    data_ptr[v->size] = value;
    v->size = v->size + 1;
}

func vector_get(v: ptr Vector, index: usize) -> i64 {
    if (index >= v->size) {
        return 0;
    }
    var data_ptr: ptr i64 = v->data;
    return data_ptr[index];
}

func vector_set(v: ptr Vector, index: usize, value: i64) {
    if (index < v->size) {
        var data_ptr: ptr i64 = v->data;
        data_ptr[index] = value;
    }
}

// HashMap simples
struct HashMapEntry {
    key: ptr;
    value: i64;
    next: ptr HashMapEntry;
}

struct HashMap {
    buckets: ptr ptr HashMapEntry;
    size: usize;
    capacity: usize;
}

func hash_string(s: ptr) -> usize {
    var hash: usize = 5381;
    var p: ptr = s;
    while (*p != 0) {
        hash = ((hash << 5) + hash) + *p;
        p = p + 1;
    }
    return hash;
}

func hashmap_new(capacity: usize) -> HashMap {
    var map: HashMap;
    map.buckets = malloc(capacity * 8);
    memset(map.buckets, 0, capacity * 8);
    map.size = 0;
    map.capacity = capacity;
    return map;
}

func hashmap_set(map: ptr HashMap, key: ptr, value: i64) {
    var hash: usize = hash_string(key) % map->capacity;
    var entry: ptr HashMapEntry = map->buckets[hash];
    
    // Procurar se a chave já existe
    while (entry != 0) {
        if (strcmp(entry->key, key) == 0) {
            entry->value = value;
            return;
        }
        entry = entry->next;
    }
    
    // Criar nova entrada
    var new_entry: ptr HashMapEntry = malloc(sizeof(HashMapEntry));
    new_entry->key = malloc(strlen(key) + 1);
    strcpy(new_entry->key, key);
    new_entry->value = value;
    new_entry->next = map->buckets[hash];
    map->buckets[hash] = new_entry;
    map->size = map->size + 1;
}

func hashmap_get(map: ptr HashMap, key: ptr) -> i64 {
    var hash: usize = hash_string(key) % map->capacity;
    var entry: ptr HashMapEntry = map->buckets[hash];
    
    while (entry != 0) {
        if (strcmp(entry->key, key) == 0) {
            return entry->value;
        }
        entry = entry->next;
    }
    
    return 0; // Não encontrado
}

// ----------------------------------------------------------------------------
// SEÇÃO 9: THREADING E SINCRONIZAÇÃO
// ----------------------------------------------------------------------------

syscall clone(flags: i32, stack: ptr, ptid: ptr, ctid: ptr, newtls: ptr) -> i32 {
    asm("mov rax, 56");
    asm("mov rdi, %0" : : "r"(flags));
    asm("mov rsi, %0" : : "r"(stack));
    asm("mov rdx, %0" : : "r"(ptid));
    asm("mov r10, %0" : : "r"(ctid));
    asm("mov r8, %0" : : "r"(newtls));
    asm("syscall");
    asm("ret");
}

syscall futex(uaddr: ptr, op: i32, val: i32, timeout: ptr, uaddr2: ptr, val3: i32) -> i32 {
    asm("mov rax, 202");
    asm("mov rdi, %0" : : "r"(uaddr));
    asm("mov rsi, %0" : : "r"(op));
    asm("mov rdx, %0" : : "r"(val));
    asm("mov r10, %0" : : "r"(timeout));
    asm("mov r8, %0" : : "r"(uaddr2));
    asm("mov r9, %0" : : "r"(val3));
    asm("syscall");
    asm("ret");
}

// Mutex simples usando futex
struct Mutex {
    lock: i32;
}

func mutex_init(m: ptr Mutex) {
    m->lock = 0;
}

func mutex_lock(m: ptr Mutex) {
    while (true) {
        var expected: i32 = 0;
        // Atomic compare-and-swap
        asm("lock cmpxchg %1, %0" : "+m"(m->lock) : "r"(1), "a"(expected));
        
        if (expected == 0) {
            break; // Lock adquirido
        }
        
        // Esperar usando futex
        futex(&m->lock, 0, 1, 0, 0, 0); // FUTEX_WAIT
    }
}

func mutex_unlock(m: ptr Mutex) {
    m->lock = 0;
    futex(&m->lock, 1, 1, 0, 0, 0); // FUTEX_WAKE
}

// ----------------------------------------------------------------------------
// SEÇÃO 10: NETWORKING
// ----------------------------------------------------------------------------

const AF_INET: i32 = 2;
const SOCK_STREAM: i32 = 1;
const SOCK_DGRAM: i32 = 2;

struct SocketAddr {
    sin_family: u16;
    sin_port: u16;
    sin_addr: u32;
    sin_zero: i8[8];
}

func htons(n: u16) -> u16 {
    return ((n & 0xFF) << 8) | ((n >> 8) & 0xFF);
}

func htonl(n: u32) -> u32 {
    return ((n & 0xFF) << 24) | 
           ((n & 0xFF00) << 8) | 
           ((n & 0xFF0000) >> 8) | 
           ((n >> 24) & 0xFF);
}

func inet_addr(ip: ptr) -> u32 {
    var result: u32 = 0;
    var part: i32 = 0;
    var shift: i32 = 24;
    var i: i32 = 0;
    
    while (ip[i] != 0) {
        if (ip[i] == '.') {
            result = result | (part << shift);
            part = 0;
            shift = shift - 8;
        } else {
            part = part * 10 + (ip[i] - '0');
        }
        i = i + 1;
    }
    result = result | part;
    
    return result;
}

func tcp_server_create(port: u16) -> i32 {
    var sockfd: i32 = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        return -1;
    }
    
    var addr: SocketAddr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr = 0; // INADDR_ANY
    memset(&addr.sin_zero, 0, 8);
    
    if (bind(sockfd, &addr, sizeof(SocketAddr)) < 0) {
        close(sockfd);
        return -1;
    }
    
    if (listen(sockfd, 128) < 0) {
        close(sockfd);
        return -1;
    }
    
    return sockfd;
}

func tcp_client_connect(ip: ptr, port: u16) -> i32 {
    var sockfd: i32 = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd < 0) {
        return -1;
    }
    
    var addr: SocketAddr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);
    addr.sin_addr = inet_addr(ip);
    memset(&addr.sin_zero, 0, 8);
    
    if (connect(sockfd, &addr, sizeof(SocketAddr)) < 0) {
        close(sockfd);
        return -1;
    }
    
    return sockfd;
}

// ----------------------------------------------------------------------------
// SEÇÃO 11: UTILITÁRIOS DE SISTEMA
// ----------------------------------------------------------------------------

syscall getpid() -> i32 {
    asm("mov rax, 39");
    asm("syscall");
    asm("ret");
}

syscall getuid() -> i32 {
    asm("mov rax, 102");
    asm("syscall");
    asm("ret");
}

syscall getgid() -> i32 {
    asm("mov rax, 104");
    asm("syscall");
    asm("ret");
}

syscall kill(pid: i32, sig: i32) -> i32 {
    asm("mov rax, 62");
    asm("mov rdi, %0" : : "r"(pid));
    asm("mov rsi, %0" : : "r"(sig));
    asm("syscall");
    asm("ret");
}

func sleep(seconds: u32) {
    var req: struct {
        tv_sec: i64;
        tv_nsec: i64;
    };
    req.tv_sec = seconds;
    req.tv_nsec = 0;
    nanosleep(&req, 0);
}

func usleep(microseconds: u64) {
    var req: struct {
        tv_sec: i64;
        tv_nsec: i64;
    };
    req.tv_sec = microseconds / 1000000;
    req.tv_nsec = (microseconds % 1000000) * 1000;
    nanosleep(&req, 0);
}

func get_timestamp_ms() -> u64 {
    var tv: struct {
        tv_sec: i64;
        tv_usec: i64;
    };
    gettimeofday(&tv, 0);
    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

// ----------------------------------------------------------------------------
// SEÇÃO 12: DRAGON ENGINE - UI X11
// ----------------------------------------------------------------------------

// Definições básicas do X11
const XCB_COPY_FROM_PARENT: u32 = 0;
const XCB_WINDOW_CLASS_INPUT_OUTPUT: u16 = 1;
const XCB_CW_BACK_PIXEL: u32 = 2;
const XCB_CW_EVENT_MASK: u32 = 2048;

struct DragonWindow {
    connection: ptr;
    window: u32;
    width: u32;
    height: u32;
    title: ptr;
}

struct DragonColor {
    r: u8;
    g: u8;
    b: u8;
    a: u8;
}

func dragon_init() -> ptr {
    // Conectar ao servidor X11 via socket
    // Implementação simplificada
    return 0;
}

func dragon_create_window(width: u32, height: u32, title: ptr) -> DragonWindow {
    var window: DragonWindow;
    window.width = width;
    window.height = height;
    window.title = malloc(strlen(title) + 1);
    strcpy(window.title, title);
    
    // Criar janela X11
    // Implementação simplificada
    
    return window;
}

func dragon_draw_rect(window: ptr DragonWindow, x: i32, y: i32, w: u32, h: u32, color: DragonColor) {
    // Desenhar retângulo na janela
    // Implementação simplificada
}

func dragon_draw_circle(window: ptr DragonWindow, x: i32, y: i32, radius: u32, color: DragonColor) {
    // Desenhar círculo usando algoritmo de Bresenham
    var dx: i32 = 0;
    var dy: i32 = radius;
    var d: i32 = 3 - 2 * radius;
    
    while (dy >= dx) {
        // Desenhar pixels do círculo
        dx = dx + 1;
        
        if (d > 0) {
            dy = dy - 1;
            d = d + 4 * (dx - dy) + 10;
        } else {
            d = d + 4 * dx + 6;
        }
    }
}

func dragon_draw_text(window: ptr DragonWindow, x: i32, y: i32, text: ptr, color: DragonColor) {
    // Desenhar texto na janela
    // Implementação simplificada
}

func dragon_update(window: ptr DragonWindow) {
    // Atualizar o buffer da janela
    // Implementação simplificada
}

func dragon_poll_events(window: ptr DragonWindow) -> i32 {
    // Processar eventos da janela
    // Retorna o tipo de evento ou 0 se não houver eventos
    return 0;
}

// ----------------------------------------------------------------------------
// FIM DA BIBLIOTECA
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// SEÇÃO 6: ULX-UI FRAMEWORK (MODERNO)
// ----------------------------------------------------------------------------

func ui_draw_card(title: ptr, content: ptr) {
    // Simulação de renderização de card holográfico
    write(1, "[UI] CARD: ", 11);
    write(1, title, strlen(title));
    write(1, " | CONTENT: ", 12);
    write(1, content, strlen(content));
    write(1, "\n", 1);
}

func ui_progress_bar(percentage: i32) {
    var buffer: i8[16];
    itoa(percentage, buffer, 10);
    write(1, "[UI] PROGRESS: ", 15);
    write(1, buffer, strlen(buffer));
    write(1, "%\n", 2);
}

// ----------------------------------------------------------------------------
// SEÇÃO 7: MÓDULOS DE IA (ALTO NÍVEL)
// ----------------------------------------------------------------------------

func ia_scan_environment() {
    write(1, "[IA] Escaneando ambiente holográfico...\n", 41);
}

func ia_detect_objects() -> i32 {
    write(1, "[IA] Objetos detectados: 3\n", 27);
    return 3;
}
